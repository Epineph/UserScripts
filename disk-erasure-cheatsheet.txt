#------------------------------------------------------------------------------
# 5. LUKS: CRYPTOGRAPHIC ERASE vs. FULL HEADER / METADATA WIPE
#------------------------------------------------------------------------------
# LUKS partitions have:
#   - Header + JSON metadata  (LUKS version, UUID, PBKDF params, etc.)
#   - Keyslots area           (encrypted master key material)
#   - Encrypted data area     (ciphertext of your actual data)
#
# For LUKS2, cryptsetup typically uses:
#   - metadata + keyslots packed into the first 16 MiB of the device
#   - a *secondary* metadata copy near the end of the device
#
# Security distinctions:
#   - "cryptographic erase" = destroy all keyslots so ciphertext is useless.
#   - "full header wipe"    = remove LUKS signature + metadata structures
#                             so tools no longer even *see* a LUKS header.
#------------------------------------------------------------------------------

# 5a) CRYPTOGRAPHIC ERASE ONLY (KEYS GONE, HEADER STILL VISIBLE)
#----------------------------------------------------------------
# This makes the LUKS volume permanently unreadable, but keeps the
# header / metadata. Tools like lsblk/blkid will still identify it
# as LUKS and luksDump will still show a header, just with no slots.
#
# Example:
#
#   sudo cryptsetup erase /dev/sdX1
#
# Notes:
#   - This removes *all active keyslots*. No passphrase will ever
#     work again; the encrypted data is done.
#   - From the man page: erase does *not* overwrite data area and
#     does *not* remove the visible metadata structure.
#   - Good when you only care about confidentiality, not about
#     hiding the fact that LUKS was used. :contentReference[oaicite:3]{index=3}
#----------------------------------------------------------------


# 5b) ALSO REMOVE LUKS SIGNATURE / METADATA (FRONT + BACK) WITH dd
#----------------------------------------------------------------
# Goal:
#   - After this, luksDump should *fail* and lsblk / blkid should
#     no longer show crypto_LUKS on that partition.
#
# Strategy (for /dev/sdX1):
#   1) Do cryptographic erase (keys gone).
#   2) Optionally wipe signatures (wipefs).
#   3) Overwrite the first N MiB (primary header + keyslots).
#   4) Overwrite the last N MiB (LUKS2 backup metadata copy).
#
# For default LUKS2 layouts N = 16 MiB is sufficient and aligns
# with the default data offset. :contentReference[oaicite:4]{index=4}
#
# DANGEROUS – EXAMPLE ONLY (replace sdX1 with actual partition):
#
#   DEV=/dev/sdX1
#
#   # 1) Cryptographic erase: kill all keyslots
#   sudo cryptsetup erase "${DEV}"
#
#   # 2) Remove filesystem/LUKS signatures so tools stop
#   #    recognizing the partition type. This does *not*
#   #    securely wipe data; it just kills magic bytes.
#   sudo wipefs -a "${DEV}"
#
#   # 3) Overwrite first 16 MiB (primary header + keyslots)
#   sudo dd if=/dev/zero of="${DEV}" bs=1M count=16 \
#     status=progress conv=fsync
#
#   # 4) Overwrite last 16 MiB (LUKS2 backup metadata area)
#   SIZE_BYTES=$(blockdev --getsize64 "${DEV}")
#   BS=$((1024*1024))             # 1 MiB
#   COUNT=16                      # MiB to wipe at each end
#   TOTAL_MIB=$(( SIZE_BYTES / BS ))
#   TAIL_SEEK=$(( TOTAL_MIB - COUNT ))
#
#   if (( TAIL_SEEK > 0 )); then
#     sudo dd if=/dev/zero of="${DEV}" bs="${BS}" count="${COUNT}" \
#       seek="${TAIL_SEEK}" status=progress conv=fsync
#   else
#     echo "[-] Device too small to wipe tail safely – aborting." >&2
#   fi
#
# Notes / caveats:
#   - This is deliberately conservative: 16 MiB is overkill for LUKS1
#     and enough for default LUKS2 header+keyslots+metadata.
#   - On large partitions this is negligible compared to the whole size.
#   - On SSDs this *does not* solve controller-level remapping issues;
#     a controller secure erase is still the "proper" solution if you
#     worry about old NAND pages outside the FTL. :contentReference[oaicite:5]{index=5}
#------------------------------------------------------------------


# 5c) OPTIONAL: AUTO-CALCULATE HEADER SIZE FROM luksDump & WIPE BOTH ENDS
#------------------------------------------------------------------
# This is more precise than "blind 16 MiB" and uses the reported
# data offset of segment 0 as header+keyslot size. It then wipes
# that much at the front and the same amount at the end.
#
# WARNING:
#   - Example helper. DO NOT run blindly. Always verify $DEV.
#   - Assumes LUKS2 style output from cryptsetup luksDump.
#------------------------------------------------------------------
#
# function wipe_luks_metadata_both_ends() {
#   local DEV="$1"
#   if [[ -z "${DEV}" ]]; then
#     echo "Usage: wipe_luks_metadata_both_ends /dev/sdX1" >&2
#     return 1
#   fi
#
#   # Safety: show what we are about to kill.
#   lsblk -o NAME,TYPE,SIZE,MOUNTPOINTS "${DEV}"
#   read -r -p "About to WIPE header+metadata on ${DEV}. Continue? [yes/NO] " a
#   [[ "${a}" == "yes" ]] || { echo "Aborted."; return 1; }
#
#   # 1) Cryptographic erase (keys gone).
#   sudo cryptsetup erase "${DEV}"
#
#   # 2) Extract data segment offset from luksDump (bytes).
#   local OFFSET_BYTES
#   OFFSET_BYTES=$(sudo cryptsetup luksDump "${DEV}" 2>/dev/null |
#     awk '/offset:[[:space:]]+[0-9]+[[:space:]]+\[bytes\]/{print $2; exit}')
#
#   if [[ -z "${OFFSET_BYTES}" ]]; then
#     echo "[-] Could not parse data offset from luksDump." >&2
#     return 1
#   fi
#
#   # Convert to MiB, rounding up:
#   #   head_mib = ceil(offset_bytes / 2^20)
#   # In integer arithmetic:
#   #   head_mib = (offset_bytes + 2^20 - 1) / 2^20
#   local BS=$((1024*1024))      # 1 MiB
#   local HEAD_MIB=$(( (OFFSET_BYTES + BS - 1) / BS ))
#
#   # 3) Remove signatures (LUKS + FS) for good measure.
#   sudo wipefs -a "${DEV}"
#
#   # 4) Overwrite front HEAD_MIB MiB.
#   sudo dd if=/dev/zero of="${DEV}" bs="${BS}" count="${HEAD_MIB}" \
#     status=progress conv=fsync
#
#   # 5) Overwrite last HEAD_MIB MiB (LUKS2 backup metadata area).
#   local SIZE_BYTES TOTAL_MIB TAIL_SEEK
#   SIZE_BYTES=$(blockdev --getsize64 "${DEV}")
#   TOTAL_MIB=$(( SIZE_BYTES / BS ))
#   TAIL_SEEK=$(( TOTAL_MIB - HEAD_MIB ))
#
#   if (( TAIL_SEEK > 0 )); then
#     sudo dd if=/dev/zero of="${DEV}" bs="${BS}" count="${HEAD_MIB}" \
#       seek="${TAIL_SEEK}" status=progress conv=fsync
#   else
#     echo "[-] Device too small for tail wipe; skipping tail." >&2
#   fi
# }
#
#------------------------------------------------------------------
# After either 5b or 5c:
#   - luksDump /dev/sdX1 should fail (no LUKS header detected).
#   - lsblk/blkid should no longer show crypto_LUKS for that partition.
#   - The encrypted payload is already unrecoverable once erase killed
#     the keyslots; header wipe is to remove metadata traces and the
#     visible "this was LUKS" signature.
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# 6. “ENCRYPT THEN DISCARD KEY” PATTERN (UNCHANGED, BUT WITH STRONGER ENDING)
#------------------------------------------------------------------------------
# (Your previous section is conceptually fine; just remember that if you
# combine it with the header wipes above, you get:
#   - ciphertext only in data area, no keys;
#   - no LUKS header, no metadata, no UUID / salt / PBKDF params;
#   - from outside it looks like random garbage, indistinguishable from
#     a wiped disk except for whatever your SSD controller chooses to
#     keep in over-provisioning.)
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# 7. QUICK REFERENCE: WHICH METHOD WHEN? (ADD LUKS HEADER WIPE ROW)
#------------------------------------------------------------------------------
# HDD (spinning):
#   → sudo wipefs -a /dev/sdX
#   → sudo dd if=/dev/zero of=/dev/sdX bs=4M status=progress conv=fsync
#
# USB stick:
#   → sudo wipefs -a /dev/sdX
#   → sudo dd if=/dev/zero of=/dev/sdX bs=4M status=progress conv=fsync
#
# SATA SSD:
#   → sudo hdparm -I /dev/sdX
#   → sudo hdparm --user-master u --security-set-pass p /dev/sdX
#   → sudo hdparm --user-master u --security-erase-enhanced p /dev/sdX
#
# NVMe SSD:
#   → sudo nvme list
#   → sudo nvme format /dev/nvme0n1 --ses=1
#
# Existing LUKS volume (keys only):
#   → sudo cryptsetup luksDump /dev/sdX1
#   → sudo cryptsetup erase /dev/sdX1
#
# Existing LUKS volume (kill keys + remove header/metadata):
#   → sudo cryptsetup erase /dev/sdX1
#   → sudo wipefs -a /dev/sdX1
#   → sudo dd if=/dev/zero of=/dev/sdX1 bs=1M count=16 \
#        status=progress conv=fsync
#   → dd tail wipe as in 5b or function in 5c
#------------------------------------------------------------------------------
